<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="SpringMVC,request,controller,DispatcherServlet," />





  <link rel="alternate" href="/atom.xml" title="逍遥居" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客http://zwgeek.com
1. 背景之前一篇文章 SpringMVC对象绑定时自定义名称对应关系 讲了如何去把request中的请求参数指定到对象的某个属性上。但文中只讲了一下做法，没有讲原理，因为这个原理涉及到SpringMVC时怎么处理Request的复杂过程。这篇文章就来和大家扒一扒这件事，SpringMVC是怎么把一个req">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMVC从request到controller过程详解">
<meta property="og:url" content="http://zwgeek.com/2016/12/29/SpringMVC从request到controller过程详解/index.html">
<meta property="og:site_name" content="逍遥居">
<meta property="og:description" content="例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客http://zwgeek.com
1. 背景之前一篇文章 SpringMVC对象绑定时自定义名称对应关系 讲了如何去把request中的请求参数指定到对象的某个属性上。但文中只讲了一下做法，没有讲原理，因为这个原理涉及到SpringMVC时怎么处理Request的复杂过程。这篇文章就来和大家扒一扒这件事，SpringMVC是怎么把一个req">
<meta property="og:image" content="http://img.blog.csdn.net/20161229134539820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20161229133354781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2017-05-09T02:55:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SpringMVC从request到controller过程详解">
<meta name="twitter:description" content="例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客http://zwgeek.com
1. 背景之前一篇文章 SpringMVC对象绑定时自定义名称对应关系 讲了如何去把request中的请求参数指定到对象的某个属性上。但文中只讲了一下做法，没有讲原理，因为这个原理涉及到SpringMVC时怎么处理Request的复杂过程。这篇文章就来和大家扒一扒这件事，SpringMVC是怎么把一个req">
<meta name="twitter:image" content="http://img.blog.csdn.net/20161229134539820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://zwgeek.com/2016/12/29/SpringMVC从request到controller过程详解/"/>

  <title> SpringMVC从request到controller过程详解 | 逍遥居 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3dacdfd5ec97423055f59e8df9a09690";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>

  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">逍遥居</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                SpringMVC从request到controller过程详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-29T13:10:47+08:00" content="2016-12-29">
              2016-12-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/服务端开发/" itemprop="url" rel="index">
                    <span itemprop="name">服务端开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/29/SpringMVC从request到controller过程详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/29/SpringMVC从request到controller过程详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/12/29/SpringMVC从request到controller过程详解/" class="leancloud_visitors" data-flag-title="SpringMVC从request到controller过程详解">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href="http://zwgeek.com">http://zwgeek.com</a></p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>之前一篇文章 <a href="http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">SpringMVC对象绑定时自定义名称对应关系</a> 讲了如何去把request中的请求参数指定到对象的某个属性上。但文中只讲了一下做法，没有讲原理，因为这个原理涉及到SpringMVC时怎么处理Request的复杂过程。这篇文章就来和大家扒一扒这件事，SpringMVC是怎么把一个request的请求最终映射到Controller的方法的。这是正向的，对于Spring来说，其实还负责把Controller的返回结果通过一些处理展现给用户，这是后话，这篇文章我们只说正向的请求，也就是从request到Controller的过程。</p>
<p>首先，来一张SpringMVC处理请求的整个过程，图是来自《Spring实战》5.1.1章，我觉得总结的非常到位，几个大的过程都画出来了。</p>
<p><img src="http://img.blog.csdn.net/20161229134539820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>我们这篇文章要说的其实就是1，2，3这三个阶段的实现原理。后面4，5，6，7可能会再开一篇文章来说，如果我的懒癌治好了的话。过程1是第二部分<strong>请求到DispatcherServlet</strong>，过程2和过程3可以总结为<strong>DispatcherServlet处理请求</strong>，也就是本文的第三部分。</p>
<h2 id="2-请求到DispatcherServlet"><a href="#2-请求到DispatcherServlet" class="headerlink" title="2. 请求到DispatcherServlet"></a>2. 请求到DispatcherServlet</h2><p>那我们按照顺序先来说一下过程1，熟悉SpringMVC的同学肯定都知道DispatcherServlet这个类，这个类是整个SpringMVC的入口。那在这个类之前做工作的其实是J2EE，不是我们重点关注的对象。只简单说一下：</p>
<p>首先一个WEB程序的入口其实是web.xml，一个请求过来，J2EE会先来这个文件中寻找合适的servlet-mapping，找到了就交给对应的Servlet处理。SpringMVC也需要在这里配一个Servlet，并且声明处理一些请求，简单点来说，我们都会让SpringMVC处理所有的请求，所以请求映射的地方就会写‘/*’，比如下面这样。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Spring web<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/web-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Spring web<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样配置一下，所有的请求就都会交给DispatcherServlet来处理了，也就是交给SpringMVC来处理了。1的过程就这么简单，想看代码实现的话可以翻翻Tomcat的代码。好，那接下来我们这篇文章重点，过程2和过程3的实现原理，也就是DispatcherServlet的处理过程。</p>
<p>DispatcherServlet作为一个标准的Servlet，生命周期也是有三个，初始化，处理请求和销毁，分别对应Servlet接口的三个方法，init(), service()和destroy()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</div><div class="line"></div><div class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们重点关注init和service的过程，destroy是service之后的过程了，可以暂时忽略不看。</p>
<h3 id="2-1-DispatcherServlet初始化"><a href="#2-1-DispatcherServlet初始化" class="headerlink" title="2.1 DispatcherServlet初始化"></a>2.1 DispatcherServlet初始化</h3><p>这里先放一张DispatcherServlet的继承关系吧</p>
<p><img src="http://img.blog.csdn.net/20161229133354781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>左边这条线就是Servlet的线，HttpServlet以及之上就是J2EE部分的代码，关注的是对请求的处理，比如doGet，doPost这些。下面HttpServletBean获取环境变量以方便子类使用。然后FrameworkServlet主要维护了自己的上下文对象webApplicationContext。我们知道一般的Servlet是不维护上下文对象的，而DispatcherServlet就是因为继承了FrameworkServlet，所以拥有了自己的上下文。简单来说大概就是这样，后面分析DispatcherServlet的工作过程的时候，还会追踪到它的这几个父类中来，到时候我们再细说。</p>
<p>首先我们先从init方法来分析DispatcherServlet的的初始化过程，这是Servlet接口中init的方法签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void init(ServletConfig var1) throws ServletException;</div></pre></td></tr></table></figure>
<p>这个带参的init方法出现在GenericServlet中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void init(ServletConfig config) throws ServletException &#123;</div><div class="line">    this.config = config;</div><div class="line">    this.init();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void init() throws ServletException &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接收了一个J2EE环境传过来的配置对象config，然后提供了一个无参的init方法供子类初始化。这个无参的init方法在HttpServletBean中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public final void init() throws ServletException &#123;</div><div class="line">        if(this.logger.isDebugEnabled()) &#123;</div><div class="line">            this.logger.debug(&quot;Initializing servlet \&apos;&quot; + this.getServletName() + &quot;\&apos;&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            //获取配置文件，就是web.xml中contextConfigLocation的值</div><div class="line">            HttpServletBean.ServletConfigPropertyValues ex = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);</div><div class="line">            //将Servlet包装成一个bean</div><div class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</div><div class="line">            //获取服务器信息</div><div class="line">            ServletContextResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext());</div><div class="line">            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));</div><div class="line">            //初始化Bean</div><div class="line">            this.initBeanWrapper(bw);</div><div class="line">            //设置配置文件到bean</div><div class="line">            bw.setPropertyValues(ex, true);</div><div class="line">            //其实以上部分没用到，因为在DispatcherServlet里initBeanWrapper没有被实现</div><div class="line">        &#125; catch (BeansException var4) &#123;</div><div class="line">            this.logger.error(&quot;Failed to set bean properties on servlet \&apos;&quot; + this.getServletName() + &quot;\&apos;&quot;, var4);</div><div class="line">            throw var4;</div><div class="line">        &#125;</div><div class="line">        //供子类初始化</div><div class="line">        this.initServletBean();</div><div class="line">        if(this.logger.isDebugEnabled()) &#123;</div><div class="line">            this.logger.debug(&quot;Servlet \&apos;&quot; + this.getServletName() + &quot;\&apos; configured successfully&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>HttpServletBean中提供了两个供子类重写的初始化方法initBeanWrapper和initServletBean，其中initBeanWrapper没有使用，DispatcherServlet使用了initServletBean来初始化接下来的工作。</p>
<p>initServletBean在FrameworkServlet中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">protected final void initServletBean() throws ServletException &#123;</div><div class="line">        this.getServletContext().log(&quot;Initializing Spring FrameworkServlet \&apos;&quot; + this.getServletName() + &quot;\&apos;&quot;);</div><div class="line">        if(this.logger.isInfoEnabled()) &#123;</div><div class="line">            this.logger.info(&quot;FrameworkServlet \&apos;&quot; + this.getServletName() + &quot;\&apos;: initialization started&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        long startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            //初始化上下文对象</div><div class="line">            this.webApplicationContext = this.initWebApplicationContext();</div><div class="line">            //提供给子类初始化</div><div class="line">            this.initFrameworkServlet();</div><div class="line">        &#125; catch (ServletException var5) &#123;</div><div class="line">            this.logger.error(&quot;Context initialization failed&quot;, var5);</div><div class="line">            throw var5;</div><div class="line">        &#125; catch (RuntimeException var6) &#123;</div><div class="line">            this.logger.error(&quot;Context initialization failed&quot;, var6);</div><div class="line">            throw var6;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(this.logger.isInfoEnabled()) &#123;</div><div class="line">            long elapsedTime = System.currentTimeMillis() - startTime;</div><div class="line">            this.logger.info(&quot;FrameworkServlet \&apos;&quot; + this.getServletName() + &quot;\&apos;: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>initFrameworkServlet是提供给子类复写的初始化方法，但是DispatcherServlet也没有用，而是用了initWebApplicationContext中的refresh方法，任性啊。initWebApplicationContext是用来初始化上下文对象的，具体逻辑如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">protected WebApplicationContext initWebApplicationContext() &#123;</div><div class="line">    //前面检查ApplicationContext是否被初始化过，如果有就直接拿来用</div><div class="line">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());</div><div class="line">    WebApplicationContext wac = null;</div><div class="line">    if(this.webApplicationContext != null) &#123;</div><div class="line">        wac = this.webApplicationContext;</div><div class="line">        if(wac instanceof ConfigurableWebApplicationContext) &#123;</div><div class="line">            ConfigurableWebApplicationContext attrName = (ConfigurableWebApplicationContext)wac;</div><div class="line">            if(!attrName.isActive()) &#123;</div><div class="line">                if(attrName.getParent() == null) &#123;</div><div class="line">                    attrName.setParent(rootContext);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                this.configureAndRefreshWebApplicationContext(attrName);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if(wac == null) &#123;</div><div class="line">        wac = this.findWebApplicationContext();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if(wac == null) &#123;</div><div class="line">        wac = this.createWebApplicationContext(rootContext);</div><div class="line">    &#125;</div><div class="line">    //Servlet自己的初始化方法</div><div class="line">    if(!this.refreshEventReceived) &#123;</div><div class="line">        this.onRefresh(wac);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //将上下文对象保存起来</div><div class="line">    if(this.publishContext) &#123;</div><div class="line">        String attrName1 = this.getServletContextAttributeName();</div><div class="line">        this.getServletContext().setAttribute(attrName1, wac);</div><div class="line">        if(this.logger.isDebugEnabled()) &#123;</div><div class="line">            this.logger.debug(&quot;Published WebApplicationContext of servlet \&apos;&quot; + this.getServletName() + &quot;\&apos; as ServletContext attribute with name [&quot; + attrName1 + &quot;]&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return wac;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法前半部分是检查之前有没有创建过ApplicationContext对象，如果有，就直接拿过来用。如果没有，则初始化一个，onRefresh则是Servlet将自己的配置加到上下文对象中的方法，DispatcherServlet也是用了这个方法来初始化各种Bean。追了一堆，init方法终于到DispatcherServlet内部了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protected void onRefresh(ApplicationContext context) &#123;</div><div class="line">    this.initStrategies(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected void initStrategies(ApplicationContext context) &#123;</div><div class="line">    this.initMultipartResolver(context);</div><div class="line">    this.initLocaleResolver(context);</div><div class="line">    this.initThemeResolver(context);</div><div class="line">    this.initHandlerMappings(context);</div><div class="line">    this.initHandlerAdapters(context);</div><div class="line">    this.initHandlerExceptionResolvers(context);</div><div class="line">    this.initRequestToViewNameTranslator(context);</div><div class="line">    this.initViewResolvers(context);</div><div class="line">    this.initFlashMapManager(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看，上面就是DispatcherServlet的一堆初始化方法。</p>
<blockquote>
<p>来自<a href="http://blog.csdn.net/snail_bi/article/details/50578371" target="_blank" rel="external">http://blog.csdn.net/snail_bi/article/details/50578371</a></p>
<ol>
<li><p>MultipartResolver:<br><a href="http://exceptioneye.iteye.com/blog/1314958" target="_blank" rel="external">http://exceptioneye.iteye.com/blog/1314958</a><br>–&gt; CommonsMultipartResolver 文件上传解析器</p>
</li>
<li><p>LocalResolver: 支持国际化,区域解析器。每DispatcherServlet只能注册一个区域解析器<br><a href="http://blog.csdn.NET/rj042/article/details/23354225" target="_blank" rel="external">http://blog.csdn.NET/rj042/article/details/23354225</a><br>–&gt; AcceptHeaderLocaleResolver 它通过检验HTTP请求的accept-language头部来解析区域。由用户的web浏览器根据底层操作系统的区域设置进行设定。<br>–&gt; SessionLocaleResolver 它通过检验用户会话中预置的属性来解析区域。如果该会话属性<br>不存在，它会根据accept-language HTTP头部确定默认区域。<br>–&gt; CookieLocaleResolver来解析区域。如果Cookie不存在，它会根据accept-language HTTP头部确定默认区域。<br>–&gt; FixedLocaleResolver 一直使用固定的Local, 不支持Local改变 。<br>修改用户的区域<br>除了显式调用LocaleResolver.setLocale()来修改用户的区域之外，还可以将LocaleChangeInterceptor拦截器应用到处理程序映射中，它会发现当前HTTP请求中出现的特殊参数。其中的参数名称可以通过拦截器的paramName属性进行自定义。如果这种参数出现在当前请求中，拦截器就会根据参数值来改变用户的区域。</p>
</li>
<li><p>ThemeSource 动态更换样式的支持(主题)<br><a href="http://starscream.iteye.com/blog/1075855" target="_blank" rel="external">http://starscream.iteye.com/blog/1075855</a><br>–&gt; FixedThemeResolver:固定格式的theme,不能在系统运行时动态更改theme.<br>–&gt; SessionThemeResolver:theme name存放在session中key值为 org.springframework.web.servlet.theme.SessionThemeResolver.THEME 的session attribute中。可在运行中通过更改session中的相应的key值来动态调整theme的值。<br>–&gt; CookieThemeResolver:theme name存放在cookie中key值为 org.springframework.web.servlet.theme.CookieThemeResolver.THEME 中。可在运行中通过更改cookie中的相应的key值来动态调整theme的值。</p>
</li>
<li><p>HandlerMapping<br><a href="http://blog.csdn.Net/sunxing007/article/details/4584748" target="_blank" rel="external">http://blog.csdn.Net/sunxing007/article/details/4584748</a><br><a href="http://blog.csdn.net/prince2270/article/details/5894456" target="_blank" rel="external">http://blog.csdn.net/prince2270/article/details/5894456</a><br>–&gt;BeanNameUrlHandlerMapping: 查找spring容器中和请求的url同名的bean.<br>–&gt;BeanNameUrlHandlerMapping ：通过对比url和bean的name找到对应的对象<br>–&gt;SimpleUrlHandlerMapping ：也是直接配置url和对应bean,比BeanNameUrlHandlerMapping功能更多<br>–&gt;DefaultAnnotationHandlerMapping : 主要是针对注解配置@RequestMapping的，已过时<br>–&gt;RequestMappingHandlerMapping ：取代了上面一个<br>–&gt; 还有很多 ，请看源码</p>
</li>
<li><p>HandlerAdapter<br>–&gt; SimpleControllerHandlerAdapter<br>–&gt; SimpleServletHandlerAdapter<br>–&gt; RequestMappingHandlerAdapter<br>–&gt; HttpRequestHandlerAdapter<br>–&gt; AnnotationMethodHandlerAdapter</p>
</li>
<li><p>HandlerExceptionResolver</p>
</li>
<li><p>RequestToViewNameTranslator  用于直接将请求转换为逻辑视图名。<br><a href="http://sishuok.com/forum/blogPost/list/0/5514.html" target="_blank" rel="external">http://sishuok.com/forum/blogPost/list/0/5514.html</a><br><a href="http://haohaoxuexi.iteye.com/blog/1774603" target="_blank" rel="external">http://haohaoxuexi.iteye.com/blog/1774603</a><br>–&gt; DefaultRequestToViewNameTranslator<br>[<br><a href="http://localhost:9080/web上下文/list" target="_blank" rel="external">http://localhost:9080/web上下文/list</a> ——-&gt; 逻辑视图名为list<br><a href="http://localhost:9080/web上下文/list.html" target="_blank" rel="external">http://localhost:9080/web上下文/list.html</a> ——-&gt; 逻辑视图名为list(默认删除扩展名)<br><a href="http://localhost:9080/web上下文/user/list.html" target="_blank" rel="external">http://localhost:9080/web上下文/user/list.html</a> ——-&gt; 逻辑视图名为user/list<br>]</p>
</li>
<li><p>ViewResolver 视图解析器：定义了如何通过view 名称来解析对应View实例的行为<br><a href="http://blog.csdn.net/prince2270/article/details/5891085" target="_blank" rel="external">http://blog.csdn.net/prince2270/article/details/5891085</a><br><a href="http://www.iteye.com/problems/76107" target="_blank" rel="external">http://www.iteye.com/problems/76107</a> 多视图问题的解决<br><a href="http://my.oschina.net/HeliosFly/blog/221392" target="_blank" rel="external">http://my.oschina.net/HeliosFly/blog/221392</a></p>
</li>
<li><p>FlashMapManager<br><a href="http://www.oschina.net/translate/spring-mvc-flash-attribute-example" target="_blank" rel="external">http://www.oschina.net/translate/spring-mvc-flash-attribute-example</a><br>–&gt; SessionFlashMapManager</p>
</li>
</ol>
</blockquote>
<p>以上就是SpringMVC在初始化的时候加入的各种处理器，对于请求到Controller的映射，比较重要的是HandlerMapping和HandlerAdapter，HandlerMapping是用来查找处理请求的对象，HandlerAdapter是用来处理请求参数。这里以HandlerAdapter来举个例子，看一下initHandlerAdapters方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">·private void initHandlerAdapters(ApplicationContext context) &#123;</div><div class="line">        this.handlerAdapters = null;</div><div class="line">        if(this.detectAllHandlerAdapters) &#123;</div><div class="line">            Map ex = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);</div><div class="line">            if(!ex.isEmpty()) &#123;</div><div class="line">                this.handlerAdapters = new ArrayList(ex.values());</div><div class="line">                OrderComparator.sort(this.handlerAdapters);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            try &#123;</div><div class="line">                HandlerAdapter ex1 = (HandlerAdapter)context.getBean(&quot;handlerAdapter&quot;, HandlerAdapter.class);</div><div class="line">                this.handlerAdapters = Collections.singletonList(ex1);</div><div class="line">            &#125; catch (NoSuchBeanDefinitionException var3) &#123;</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(this.handlerAdapters == null) &#123;</div><div class="line">            this.handlerAdapters = this.getDefaultStrategies(context, HandlerAdapter.class);</div><div class="line">            if(this.logger.isDebugEnabled()) &#123;</div><div class="line">                this.logger.debug(&quot;No HandlerAdapters found in servlet \&apos;&quot; + this.getServletName() + &quot;\&apos;: using default&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面的逻辑是这样的</p>
<blockquote>
<p>1)如果detectAllHandlerAdapters属性为true(默认为true)，根据类型匹配(HandlerAdapter)机制查找上下文及父Spring容器中所有匹配的Bean，将它们作为该类型组件；<br>2)如果detectAllHandlerAdapters属性为false，查找名为handlerAdapter类型为HandlerAdapter的Bean作为该类型组件；<br>3)如果通过以上方式都找不到，使用DispatcherServlet.properties配置文件中指定的三个实现类分别创建一个适配器，添加到适配器列表中。</p>
</blockquote>
<p>DispatcherServlet.properties和DispatcherServlet在同一个包下，定义了一些默认的类，内容如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</div><div class="line">	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</div><div class="line">	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</div><div class="line">	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</div><div class="line">	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</div><div class="line">	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class="line"></div><div class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure>
<p>我们看到HandlerAdapter是有三个默认类，如果程序从上下文中找不到任何HandlerAdapter，就会把这三个加载进来。</p>
<p>DispatcherServlet结束了onRefresh的一系列方法，初始化过程就结束了。接下来就是一个请求到来的时候的处理工作了。</p>
<h2 id="3-Dispatcher处理请求"><a href="#3-Dispatcher处理请求" class="headerlink" title="3. Dispatcher处理请求"></a>3. Dispatcher处理请求</h2><h3 id="3-1-预处理请求"><a href="#3-1-预处理请求" class="headerlink" title="3.1 预处理请求"></a>3.1 预处理请求</h3><p>请求到来的时候，J2EE会调用相应Servlet的onService方法，对于DispatcherServlet来说，这个onService在FrameworkServlet里，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</div><div class="line">        String method = request.getMethod();</div><div class="line">        if(method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123;</div><div class="line">            this.processRequest(request, response);</div><div class="line">        &#125; else &#123;</div><div class="line">            super.service(request, response);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法补充了对PATCH请求类型的处理，其他请求类型如GET，PUT，调用了super的service方法，也就是在HttpServlet的service方法(HttpServletBean中没有复写)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class="line">        String method = req.getMethod();</div><div class="line">        long errMsg;</div><div class="line">        if(method.equals(&quot;GET&quot;)) &#123;</div><div class="line">            errMsg = this.getLastModified(req);</div><div class="line">            if(errMsg == -1L) &#123;</div><div class="line">                this.doGet(req, resp);</div><div class="line">            &#125; else &#123;</div><div class="line">                long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);</div><div class="line">                if(ifModifiedSince &lt; errMsg / 1000L * 1000L) &#123;</div><div class="line">                    this.maybeSetLastModified(resp, errMsg);</div><div class="line">                    this.doGet(req, resp);</div><div class="line">                &#125; else &#123;</div><div class="line">                    resp.setStatus(304);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else if(method.equals(&quot;HEAD&quot;)) &#123;</div><div class="line">            errMsg = this.getLastModified(req);</div><div class="line">            this.maybeSetLastModified(resp, errMsg);</div><div class="line">            this.doHead(req, resp);</div><div class="line">        &#125; else if(method.equals(&quot;POST&quot;)) &#123;</div><div class="line">            this.doPost(req, resp);</div><div class="line">        &#125; else if(method.equals(&quot;PUT&quot;)) &#123;</div><div class="line">            this.doPut(req, resp);</div><div class="line">        &#125; else if(method.equals(&quot;DELETE&quot;)) &#123;</div><div class="line">            this.doDelete(req, resp);</div><div class="line">        &#125; else if(method.equals(&quot;OPTIONS&quot;)) &#123;</div><div class="line">            this.doOptions(req, resp);</div><div class="line">        &#125; else if(method.equals(&quot;TRACE&quot;)) &#123;</div><div class="line">            this.doTrace(req, resp);</div><div class="line">        &#125; else &#123;</div><div class="line">            String errMsg1 = lStrings.getString(&quot;http.method_not_implemented&quot;);</div><div class="line">            Object[] errArgs = new Object[]&#123;method&#125;;</div><div class="line">            errMsg1 = MessageFormat.format(errMsg1, errArgs);</div><div class="line">            resp.sendError(501, errMsg1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法也很简单，根据不同的请求类型调用不同的方法，这里我们假设请求是个GET请求，那就会去执行子类的doGet方法，在FrameworkServlet里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</div><div class="line">        this.processRequest(request, response);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>也没做什么，交给了processRequest处理，其实其他请求最后也都转给processRequest这个方法处理了，因为处理参数的逻辑是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</div><div class="line">    long startTime = System.currentTimeMillis();</div><div class="line">    Object failureCause = null;</div><div class="line">    //获取之前的位置信息，最后finally时恢复之前配置</div><div class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</div><div class="line">    LocaleContext localeContext = this.buildLocaleContext(request);</div><div class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</div><div class="line">    ServletRequestAttributes requestAttributes = this.buildRequestAttributes(request, response, previousAttributes);</div><div class="line">    //注册Interceptor，没理解干嘛的</div><div class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new FrameworkServlet.RequestBindingInterceptor(null));</div><div class="line">    //将请求中的位置信息记入</div><div class="line">    this.initContextHolders(request, localeContext, requestAttributes);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        //做事情</div><div class="line">        this.doService(request, response);</div><div class="line">    &#125; catch (ServletException var18) &#123;</div><div class="line">        failureCause = var18;</div><div class="line">        throw var18;</div><div class="line">    &#125; catch (IOException var19) &#123;</div><div class="line">        failureCause = var19;</div><div class="line">        throw var19;</div><div class="line">    &#125; catch (Throwable var20) &#123;</div><div class="line">        failureCause = var20;</div><div class="line">        throw new NestedServletException(&quot;Request processing failed&quot;, var20);</div><div class="line">    &#125; finally &#123;</div><div class="line">    //恢复之前配置</div><div class="line">        this.resetContextHolders(request, previousLocaleContext, previousAttributes);</div><div class="line">        if(requestAttributes != null) &#123;</div><div class="line">            requestAttributes.requestCompleted();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(this.logger.isDebugEnabled()) &#123;</div><div class="line">            if(failureCause != null) &#123;</div><div class="line">                this.logger.debug(&quot;Could not complete request&quot;, (Throwable)failureCause);</div><div class="line">            &#125; else if(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                this.logger.debug(&quot;Leaving response open for concurrent processing&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                this.logger.debug(&quot;Successfully completed request&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">       //发布事件 this.publishRequestHandledEvent(request, startTime, (Throwable)failureCause);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先说下发布事件，Spring在请求处理结束后会发布一个ServletRequestHandledEvent类型的事件，可以通过ApplicationListener接收。</p>
<p>这个方法前面和后面做的工作是保留现场，请求处理结束后恢复现场。真正处理请求的方法是doService。这个方法在DispatcherServlet中。</p>
<p>话语权终于到DispatcherServlet中了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</div><div class="line">    if(this.logger.isDebugEnabled()) &#123;</div><div class="line">        String attributesSnapshot = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult()?&quot; resumed&quot;:&quot;&quot;;</div><div class="line">        this.logger.debug(&quot;DispatcherServlet with name \&apos;&quot; + this.getServletName() + &quot;\&apos;&quot; + attributesSnapshot + &quot; processing &quot; + request.getMethod() + &quot; request for [&quot; + getRequestUri(request) + &quot;]&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    HashMap attributesSnapshot1 = null;</div><div class="line">    //处理include类型的request，用不到</div><div class="line">    if(WebUtils.isIncludeRequest(request)) &#123;</div><div class="line">        attributesSnapshot1 = new HashMap();</div><div class="line">        Enumeration inputFlashMap = request.getAttributeNames();</div><div class="line"></div><div class="line">        label113:</div><div class="line">        while(true) &#123;</div><div class="line">            String attrName;</div><div class="line">            do &#123;</div><div class="line">                if(!inputFlashMap.hasMoreElements()) &#123;</div><div class="line">                    break label113;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                attrName = (String)inputFlashMap.nextElement();</div><div class="line">            &#125; while(!this.cleanupAfterInclude &amp;&amp; !attrName.startsWith(&quot;org.springframework.web.servlet&quot;));</div><div class="line"></div><div class="line">            attributesSnapshot1.put(attrName, request.getAttribute(attrName));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //将现在的各种参数加到Request中</div><div class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.getWebApplicationContext());</div><div class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);</div><div class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);</div><div class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, this.getThemeSource());</div><div class="line">    FlashMap inputFlashMap1 = this.flashMapManager.retrieveAndUpdate(request, response);</div><div class="line">    if(inputFlashMap1 != null) &#123;</div><div class="line">        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap1));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());</div><div class="line">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        //做事情</div><div class="line">        this.doDispatch(request, response);</div><div class="line">    &#125; finally &#123;</div><div class="line">        if(WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(attributesSnapshot1 != null) &#123;</div><div class="line">            this.restoreAttributesAfterInclude(request, attributesSnapshot1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法主要是把现在有的一些参数比如上下文对象加到Request中，然后转发到doDispatch方法去处理，终于到了最关键的方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</div><div class="line">    HttpServletRequest processedRequest = request;</div><div class="line">    HandlerExecutionChain mappedHandler = null;</div><div class="line">    boolean multipartRequestParsed = false;</div><div class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        try &#123;</div><div class="line">            ModelAndView err = null;</div><div class="line">            Exception dispatchException = null;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                processedRequest = this.checkMultipart(request);</div><div class="line">                multipartRequestParsed = processedRequest != request;</div><div class="line">                //获取Hanlder</div><div class="line">                mappedHandler = this.getHandler(processedRequest, false);</div><div class="line">                if(mappedHandler == null || mappedHandler.getHandler() == null) &#123;</div><div class="line">                    this.noHandlerFound(processedRequest, response);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                //获取Adapter</div><div class="line">                HandlerAdapter ex = this.getHandlerAdapter(mappedHandler.getHandler());</div><div class="line">                String method = request.getMethod();</div><div class="line">                boolean isGet = &quot;GET&quot;.equals(method);</div><div class="line">                if(isGet || &quot;HEAD&quot;.equals(method)) &#123;</div><div class="line">                    long lastModified = ex.getLastModified(request, mappedHandler.getHandler());</div><div class="line">                    if(this.logger.isDebugEnabled()) &#123;</div><div class="line">                        this.logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                //执行preHandle方法</div><div class="line">                if(!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                 //执行Handle方法                    </div><div class="line">                try &#123;</div><div class="line">                    err = ex.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line">                &#125; finally &#123;</div><div class="line">                    if(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                //处理默认的ViewName</div><div class="line">                this.applyDefaultViewName(request, err);</div><div class="line">                //执行PostHandle</div><div class="line">                mappedHandler.applyPostHandle(processedRequest, response, err);</div><div class="line">            &#125; catch (Exception var27) &#123;</div><div class="line">                dispatchException = var27;</div><div class="line">            &#125;</div><div class="line">            //处理返回结果，绘制View</div><div class="line">            this.processDispatchResult(processedRequest, response, mappedHandler, err, dispatchException);</div><div class="line">        &#125; catch (Exception var28) &#123;</div><div class="line">            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var28);</div><div class="line">        &#125; catch (Error var29) &#123;</div><div class="line">            this.triggerAfterCompletionWithError(processedRequest, response, mappedHandler, var29);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; finally &#123;</div><div class="line">        if(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</div><div class="line">            return;</div><div class="line">        &#125; else &#123;</div><div class="line">            if(multipartRequestParsed) &#123;</div><div class="line">                this.cleanupMultipart(processedRequest);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这个方法可以说是整个SpringMVC中最重要的方法，但是整个流程缺及其简单，可以说这一切都归功于Spring框架高度的抽象。我们来梳理一下这个doDispatch方法的流程。</p>
<ol>
<li>获取Handler</li>
<li>获取Adapter</li>
<li>执行preHandle方法</li>
<li>执行Handle方法</li>
<li>执行PostHandle</li>
<li>处理返回结果</li>
</ol>
<p>5和6是Controller请求处理结束后的操作，本文中我们只讨论1-2-3-4这四个步骤。1-2-3-4这四个步骤对应了一开始提到的SpringMVC的七大步中的第二步请求到处理器映射和第三步请求到控制器。其中1-2是请求到处理器映射，3-4是请求到控制器。下面我们一步一步的来看。</p>
<h3 id="3-2-根据请求获取Handler"><a href="#3-2-根据请求获取Handler" class="headerlink" title="3.2 根据请求获取Handler"></a>3.2 根据请求获取Handler</h3><p>首先第一步是根据request，获取合适的Handler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mappedHandler = this.getHandler(processedRequest, false);</div></pre></td></tr></table></figure>
<p>这里返回的结果是HandlerExecutionChain类型的，从名字我们知道这是一个执行链，里面包含了这个Handler所有相关的信息。下面我们来看下getHandler方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</div><div class="line">        Iterator i$ = this.handlerMappings.iterator();</div><div class="line"></div><div class="line">        HandlerExecutionChain handler;</div><div class="line">        do &#123;</div><div class="line">            if(!i$.hasNext()) &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            HandlerMapping hm = (HandlerMapping)i$.next();</div><div class="line">            if(this.logger.isTraceEnabled()) &#123;</div><div class="line">                this.logger.trace(&quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name \&apos;&quot; + this.getServletName() + &quot;\&apos;&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            handler = hm.getHandler(request);</div><div class="line">        &#125; while(handler == null);</div><div class="line"></div><div class="line">        return handler;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>遍历HandlerMappings，然后依次调用每个HandlerMappings的getHandler方法，如果有返回就交给该Handler处理。</p>
<p>这个HandlerMappings是DispatcherServlet初始化的时候加入的，在initHandlerMapping方法里。我们看下系统默认的HandlerMapping都有哪些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</div><div class="line">	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div></pre></td></tr></table></figure>
<p>我的项目自定义了一个HandlerMappings，也是基于注解的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!--配置注解式处理器映射器--&gt;</div><div class="line"> &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</div></pre></td></tr></table></figure>
<p>我们来看一下他是怎么工作的。getHandler方法。这个方法在RequestMappingHandlerMapping的父类AbstractHandlerMapping中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</div><div class="line">        Object handler = this.getHandlerInternal(request);</div><div class="line">        if(handler == null) &#123;</div><div class="line">            handler = this.getDefaultHandler();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(handler == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125; else &#123;</div><div class="line">            if(handler instanceof String) &#123;</div><div class="line">                String handlerName = (String)handler;</div><div class="line">                handler = this.getApplicationContext().getBean(handlerName);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return this.getHandlerExecutionChain(handler, request);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Spring框架一贯的套路，父类定义流程，开一个方法供子类去实现，比如这里的getHandlerInternal，返回了Handler之后，再用HandlerExecutionChain包装一下。那先来看下getHandlerInternal方法是怎么获取Handler的。这个方法依然在RequestMappingHandlerMapping的父类AbstractHandlerMethodMapping中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;</div><div class="line">        String lookupPath = this.getUrlPathHelper().getLookupPathForRequest(request);</div><div class="line">        if(this.logger.isDebugEnabled()) &#123;</div><div class="line">            this.logger.debug(&quot;Looking up handler method for path &quot; + lookupPath);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HandlerMethod handlerMethod = this.lookupHandlerMethod(lookupPath, request);</div><div class="line">        if(this.logger.isDebugEnabled()) &#123;</div><div class="line">            if(handlerMethod != null) &#123;</div><div class="line">                this.logger.debug(&quot;Returning handler method [&quot; + handlerMethod + &quot;]&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                this.logger.debug(&quot;Did not find handler method for [&quot; + lookupPath + &quot;]&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return handlerMethod != null?handlerMethod.createWithResolvedBean():null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>两个重要的方法，getLookupPathForRequest和lookupHandlerMethod，这里我就不贴代码了，说一下实现原理吧，其实RequestMappingHandlerMapping在初始化的时候已经将系统中所有的@RequestMapping注解解析了，放在一个Map里面。实现过程如下。</p>
<p>RequestMappingHandlerMapping的父类AbstractHandlerMethodMapping实现了InitializingBean接口，在Bean设置完参数后会调用afterPropertiesSet方法，而它在这个方法里面做了初始化的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public void afterPropertiesSet() &#123;</div><div class="line">       this.initHandlerMethods();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   protected void initHandlerMethods() &#123;</div><div class="line">       if(this.logger.isDebugEnabled()) &#123;</div><div class="line">           this.logger.debug(&quot;Looking for request mappings in application context: &quot; + this.getApplicationContext());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       String[] beanNames = this.detectHandlerMethodsInAncestorContexts?BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.getApplicationContext(), Object.class):this.getApplicationContext().getBeanNamesForType(Object.class);</div><div class="line">       String[] arr$ = beanNames;</div><div class="line">       int len$ = beanNames.length;</div><div class="line"></div><div class="line">       for(int i$ = 0; i$ &lt; len$; ++i$) &#123;</div><div class="line">           String beanName = arr$[i$];</div><div class="line">           //判断类中是否含有RequestMapping注释</div><div class="line">           if(this.isHandler(this.getApplicationContext().getType(beanName))) &#123;</div><div class="line">               //解析方法</div><div class="line">               this.detectHandlerMethods(beanName);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       this.handlerMethodsInitialized(this.getHandlerMethods());</div><div class="line">   &#125;</div><div class="line">   </div><div class="line"> protected void detectHandlerMethods(Object handler) &#123;</div><div class="line">       Class handlerType = handler instanceof String?this.getApplicationContext().getType((String)handler):handler.getClass();</div><div class="line">       final IdentityHashMap mappings = new IdentityHashMap();</div><div class="line">       final Class userType = ClassUtils.getUserClass(handlerType);</div><div class="line">       Set methods = HandlerMethodSelector.selectMethods(userType, new MethodFilter() &#123;</div><div class="line">           public boolean matches(Method method) &#123;</div><div class="line">               Object mapping = AbstractHandlerMethodMapping.this.getMappingForMethod(method, userType);</div><div class="line">               if(mapping != null) &#123;</div><div class="line">                   mappings.put(method, mapping);</div><div class="line">                   return true;</div><div class="line">               &#125; else &#123;</div><div class="line">                   return false;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       Iterator i$ = methods.iterator();</div><div class="line"></div><div class="line">       while(i$.hasNext()) &#123;</div><div class="line">           Method method = (Method)i$.next();</div><div class="line">           //注册方法，加到urlMaps里面</div><div class="line">           this.registerHandlerMethod(handler, method, mappings.get(method));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这样RequestMappingHandlerMapping 里面就有了所有Controller方法的信息。getLookupPathForRequest就是获取请求的地址，比如我请求的是<a href="http://localhost:8090/test，那这里getLookupPathForRequest返回的就是/test。现在只要查询一下RequestMappingHandlerMapping里面有没有key为/test的的value即可，value中有处理的类的Controller对应的bean" target="_blank" rel="external">http://localhost:8090/test，那这里getLookupPathForRequest返回的就是/test。现在只要查询一下RequestMappingHandlerMapping里面有没有key为/test的的value即可，value中有处理的类的Controller对应的bean</a> name，然后下面createWithResolvedBean包装一下返回一个HandlerMethod。返回的HandlerMethod再通过getHandlerExecutionChain包装成HandlerExecutionChain，HandlerExecutionChain里面有什么呢，我们来看一下getHandlerExecutionChain方法是怎么写的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;</div><div class="line">       HandlerExecutionChain chain = handler instanceof HandlerExecutionChain?(HandlerExecutionChain)handler:new HandlerExecutionChain(handler);</div><div class="line">       chain.addInterceptors(this.getAdaptedInterceptors());</div><div class="line">       String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);</div><div class="line">       Iterator i$ = this.mappedInterceptors.iterator();</div><div class="line"></div><div class="line">       while(i$.hasNext()) &#123;</div><div class="line">           MappedInterceptor mappedInterceptor = (MappedInterceptor)i$.next();</div><div class="line">           if(mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123;</div><div class="line">               chain.addInterceptor(mappedInterceptor.getInterceptor());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return chain;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其实就是把Interceptor加进去，你可以通过自定义Interceptor来对一个request的前后做相应的处理，下面是HandlerInterceptor接口的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface HandlerInterceptor &#123;</div><div class="line">    boolean preHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;</div><div class="line"></div><div class="line">    void postHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4) throws Exception;</div><div class="line"></div><div class="line">    void afterCompletion(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就获取到了处理这个request对应的Controller，以及方法名了，控制权又交回到doDispatch方法中去了。</p>
<h3 id="3-3-根据处理器获取相应的处理器Adapter适配器"><a href="#3-3-根据处理器获取相应的处理器Adapter适配器" class="headerlink" title="3.3 根据处理器获取相应的处理器Adapter适配器"></a>3.3 根据处理器获取相应的处理器Adapter适配器</h3><p>接下来是第二步获取Adapter，这个Adapter的作用主要是把请求中的参数和Controller方法中的参数对应起来，所以就会做一些类型转换相应的工作，也就是下一步，这一部分也是我觉得request到Controller的映射过程中最复杂的一步，不过获取Adapter相对简单。</p>
<p>首先看下getHandlerAdapter的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;</div><div class="line">       Iterator i$ = this.handlerAdapters.iterator();</div><div class="line"></div><div class="line">       HandlerAdapter ha;</div><div class="line">       do &#123;</div><div class="line">           if(!i$.hasNext()) &#123;</div><div class="line">               throw new ServletException(&quot;No adapter for handler [&quot; + handler + &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           ha = (HandlerAdapter)i$.next();</div><div class="line">           if(this.logger.isTraceEnabled()) &#123;</div><div class="line">               this.logger.trace(&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125; while(!ha.supports(handler));</div><div class="line"></div><div class="line">       return ha;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> 从初始化的handlerAdapters中取出可以处理相应handler的，如果没有自定义，系统会预置几个，这个前面也说到了。这里我们看下supports方法吧，看下handlerAdapter是怎么判断它自己能否处理这个handler的。我目前项目用的是RequestMappingHandlerAdapter这里Adapter处理类。它的supports方法在他的父类AbstractHandlerMethodAdapter上。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final boolean supports(Object handler) &#123;</div><div class="line">       return handler instanceof HandlerMethod &amp;&amp; this.supportsInternal((HandlerMethod)handler);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected boolean supportsInternal(HandlerMethod handlerMethod) &#123;</div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> RequestMappingHandlerAdapter的supportsInternal方法是永远返回true的，所以只要handler的类型是HandlerMethod，这个RequestMappingHandlerAdapter都会处理。这个RequestMappingHandlerAdapter其实是个比较通用的Adapter类。</p>
<h3 id="3-4-执行preHandle方法和Handle方法"><a href="#3-4-执行preHandle方法和Handle方法" class="headerlink" title="3.4 执行preHandle方法和Handle方法"></a>3.4 执行preHandle方法和Handle方法</h3><p> 获取到了Adapter，接下来就要做实际的事情了，执行preHandle方法很简单，就是调用一下，其实是为了用户定制。接下来真正处理事情的是adapter的handle方法。也就是我们上面提到的doDispatch的第四步。</p>
<p> AbstractHandlerMethodAdapter的handle方法按照Spring的国际惯例肯定，自己做了点保存现场啥的工作，然后定义一个方法让子类去做实际的事情了。我瞅了一眼，我觉得我还是高估这个父类了，它啥都没做直接调用了子类的handleInternal方法。RequestMappingHandlerAdapter中handleInternal的实现是这样的。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">protected final ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</div><div class="line">       if(this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</div><div class="line">           this.checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);</div><div class="line">       &#125; else &#123;</div><div class="line">           this.checkAndPrepare(request, response, true);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if(this.synchronizeOnSession) &#123;</div><div class="line">           HttpSession session = request.getSession(false);</div><div class="line">           if(session != null) &#123;</div><div class="line">               Object mutex = WebUtils.getSessionMutex(session);</div><div class="line">               synchronized(mutex) &#123;</div><div class="line">                   return this.invokeHandleMethod(request, response, handlerMethod);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return this.invokeHandleMethod(request, response, handlerMethod);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> 又分了两部分，一个是checkAndPrepare，另一个是invokeHandleMethod，从名字也可以看出，一个事准备，一个事调用方法。按步骤一个一个来，先看看checkAndPrepare做了什么。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected final void checkAndPrepare(HttpServletRequest request, HttpServletResponse response, int cacheSeconds, boolean lastModified) throws ServletException &#123;</div><div class="line">       String method = request.getMethod();</div><div class="line">       if(this.supportedMethods != null &amp;&amp; !this.supportedMethods.contains(method)) &#123;</div><div class="line">           throw new HttpRequestMethodNotSupportedException(method, StringUtils.toStringArray(this.supportedMethods));</div><div class="line">       &#125; else if(this.requireSession &amp;&amp; request.getSession(false) == null) &#123;</div><div class="line">           throw new HttpSessionRequiredException(&quot;Pre-existing session required but none found&quot;);</div><div class="line">       &#125; else &#123;</div><div class="line">           this.applyCacheSeconds(response, cacheSeconds, lastModified);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> 检查了是否支持请求方法，然后调用了applyCacheSeconds来处理缓存时间戳。也没什么重要的是不是，所以处理参数的其实下面这个方法invokeHandleMethod。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private ModelAndView invokeHandleMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</div><div class="line">		 //初始化ServletWebRequest</div><div class="line">       ServletWebRequest webRequest = new ServletWebRequest(request, response);</div><div class="line">       //获取类型转换器</div><div class="line">       WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod);</div><div class="line">       ModelFactory modelFactory = this.getModelFactory(handlerMethod, binderFactory);</div><div class="line">       //创建Method映射</div><div class="line">       ServletInvocableHandlerMethod requestMappingMethod = this.createRequestMappingMethod(handlerMethod, binderFactory);</div><div class="line">       //创建ModelandView包装器</div><div class="line">       ModelAndViewContainer mavContainer = new ModelAndViewContainer();</div><div class="line">       mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</div><div class="line">       modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</div><div class="line">       mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</div><div class="line">       //异步相关</div><div class="line">       AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</div><div class="line">       asyncWebRequest.setTimeout(this.asyncRequestTimeout);</div><div class="line">       WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line">       asyncManager.setTaskExecutor(this.taskExecutor);</div><div class="line">       asyncManager.setAsyncWebRequest(asyncWebRequest);</div><div class="line">       asyncManager.registerCallableInterceptors(this.callableInterceptors);</div><div class="line">       asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</div><div class="line">       if(asyncManager.hasConcurrentResult()) &#123;</div><div class="line">           Object result = asyncManager.getConcurrentResult();</div><div class="line">           mavContainer = (ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0];</div><div class="line">           asyncManager.clearConcurrentResult();</div><div class="line">           if(this.logger.isDebugEnabled()) &#123;</div><div class="line">               this.logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       requestMappingMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);</div><div class="line">       return asyncManager.isConcurrentHandlingStarted()?null:this.getModelAndView(mavContainer, modelFactory, webRequest);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> 现在requestMappingMethod中有了方法信息，有了请求信息，就到了invokeAndHandle。invokeAndHandle中又调了invokeForRequest</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public final Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123;</div><div class="line">       Object[] args = this.getMethodArgumentValues(request, mavContainer, providedArgs);</div><div class="line">       if(this.logger.isTraceEnabled()) &#123;</div><div class="line">           StringBuilder returnValue = new StringBuilder(&quot;Invoking [&quot;);</div><div class="line">           returnValue.append(this.getBeanType().getSimpleName()).append(&quot;.&quot;);</div><div class="line">           returnValue.append(this.getMethod().getName()).append(&quot;] method with arguments &quot;);</div><div class="line">           returnValue.append(Arrays.asList(args));</div><div class="line">           this.logger.trace(returnValue.toString());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       Object returnValue1 = this.invoke(args);</div><div class="line">       if(this.logger.isTraceEnabled()) &#123;</div><div class="line">           this.logger.trace(&quot;Method [&quot; + this.getMethod().getName() + &quot;] returned [&quot; + returnValue1 + &quot;]&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return returnValue1;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> invokeForRequest方法通过getMethodArgumentValues从request中获取到了方法的参数列表args，然后调用了invoke反射调用了方法。所以可以看出getMethodArgumentValues中做了request参数到方法参数的转换。继续到里面看。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123;</div><div class="line">		 //获取所有参数</div><div class="line">       MethodParameter[] parameters = this.getMethodParameters();</div><div class="line">       Object[] args = new Object[parameters.length];</div><div class="line"></div><div class="line">	 //每个参数进行处理，从request中找到参数值</div><div class="line">       for(int i = 0; i &lt; parameters.length; ++i) &#123;</div><div class="line">           MethodParameter parameter = parameters[i];</div><div class="line">           parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);</div><div class="line">           //处理提供的数据类型转换，这里传值new Object，所以没用到</div><div class="line">           GenericTypeResolver.resolveParameterType(parameter, this.getBean().getClass());</div><div class="line">           args[i] = this.resolveProvidedArgument(parameter, providedArgs);</div><div class="line">           //如果前面提供的数据类型无法转换</div><div class="line">           if(args[i] == null) &#123;</div><div class="line">               //判断自己的类型转换器能否支持该参数类型</div><div class="line">               if(this.argumentResolvers.supportsParameter(parameter)) &#123;</div><div class="line">                   try &#123;</div><div class="line">                   	//转换参数</div><div class="line">                       args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</div><div class="line">                   &#125; catch (Exception var9) &#123;</div><div class="line">                       if(this.logger.isTraceEnabled()) &#123;</div><div class="line">                           this.logger.trace(this.getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), var9);</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       throw var9;</div><div class="line">                   &#125;</div><div class="line">               &#125; else if(args[i] == null) &#123;</div><div class="line">                   String msg = this.getArgumentResolutionErrorMessage(&quot;No suitable resolver for argument&quot;, i);</div><div class="line">                   throw new IllegalStateException(msg);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return args;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>逻辑在注释中写的差不多了，重点的地方是this.argumentResolvers.supportsParameter(parameter)用来判断自己的参数类型转换器是否支持这种参数类型，然后this.argumentResolvers.resolveArgument来处理参数类型转换。</p>
<p>先来看下this.argumentResolvers.supportsParameter(parameter)，argumentResolvers是一个HandlerMethodArgumentResolverComposite类型的变量，HandlerMethodArgumentResolverComposite是一个Resolver的包装器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</div><div class="line">       return this.getArgumentResolver(parameter) != null;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;</div><div class="line">       HandlerMethodArgumentResolver result = (HandlerMethodArgumentResolver)this.argumentResolverCache.get(parameter);</div><div class="line">       if(result == null) &#123;</div><div class="line">           Iterator i$ = this.argumentResolvers.iterator();</div><div class="line"></div><div class="line">           while(i$.hasNext()) &#123;</div><div class="line">               HandlerMethodArgumentResolver methodArgumentResolver = (HandlerMethodArgumentResolver)i$.next();</div><div class="line">               if(this.logger.isTraceEnabled()) &#123;</div><div class="line">                   this.logger.trace(&quot;Testing if argument resolver [&quot; + methodArgumentResolver + &quot;] supports [&quot; + parameter.getGenericParameterType() + &quot;]&quot;);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               if(methodArgumentResolver.supportsParameter(parameter)) &#123;</div><div class="line">                   result = methodArgumentResolver;</div><div class="line">                   this.argumentResolverCache.put(parameter, methodArgumentResolver);</div><div class="line">                   break;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>methodArgumentResolver.supportsParameter(parameter)这一句调用了每个Resolver的support方法。关于Resolver是什么，可以看我的上一篇博客。</p>
<p><a href="http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">SpringMVC对象绑定时自定义名称对应关系</a></p>
<p>其实简单来说就是一种类型处理器，我的项目在运行的时候回默认置入24个类型处理器，基本能处理各种类型转换，另外也可以自己自定义类型处理器。传送门里的文章有讲，包括类型处理器是怎么处理类型转换的，里面也有说。总之，类型处理器在argumentResolvers.resolveArgument处理完参数后，会把request的参数转成一个Object[]的列表返回，就是Controller中方法的参数列表。</p>
<p>然后invokeForRequest方法会调用invoke去通过反射调用到Controller中对应的方法。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>恩，到目前为止，一个request已经被SpringMVC处理后调到了Controller中对应的方法。然后Controller里面就是我们自己的逻辑了。接下来还有doDispatch的后几步，处理Controller的返回并处理成视图返回给用户。这个在以后的文章中慢慢说明。</p>
<p>看Spring的源码，有一个很大的感受就是把抽象接口运用到了极致，几乎所有的处理器都会抽象出一个接口，然后下面会有各种各样的实现。这样处理之后整个流程几乎不涉及具体业务，只有流程规范，非常的容易理解。不得不说是一个让强迫症患者神清气爽的框架。</p>
<p>另外还有一个感受就是，这套框架非常灵活。几乎所有的类都可以做的定制化，每一步处理过程都可以定制化，这样有利有弊，好处就是非常灵活，没有解决不了的问题，坏处就是可能一个地方没理解清楚就会出错。所有在定制化的时候还是要小心一点。</p>
<p>接下来应该会有两篇文章，一篇是讲SpringMVC框架处理Controller的返回结果到视图，再一篇讲下Spring框架初始化Bean和BeanFactory的过程，其实也都在上面讲的流程里面，只是我略过去了。</p>
<p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href="http://zwgeek.com">http://zwgeek.com</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/uploads/wechat-reward-image.jpeg" alt="轩辕 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SpringMVC/" rel="tag">#SpringMVC</a>
          
            <a href="/tags/request/" rel="tag">#request</a>
          
            <a href="/tags/controller/" rel="tag">#controller</a>
          
            <a href="/tags/DispatcherServlet/" rel="tag">#DispatcherServlet</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/28/SpringMVC对象绑定自定义名称对应关系/" rel="next" title="SpringMVC对象绑定时自定义名称对应关系">
                <i class="fa fa-chevron-left"></i> SpringMVC对象绑定时自定义名称对应关系
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/09/fastjson使用过程中的坑/" rel="prev" title="fastjson使用过程中的坑">
                fastjson使用过程中的坑 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          
  <div class="comments" id="comments">
  <!--PC和WAP自适应版-->
<div id="SOHUCS" ></div> 
<script type="text/javascript"> 
(function(){ 
var appid = 'cyt0SiYIG'; 
var conf = 'prod_8b6ae98478e792e771042310b91a3839'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("http://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="轩辕" />
          <p class="site-author-name" itemprop="name">轩辕</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/xuan-yuan-40-22" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/zgzczzw" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/zgzczzw" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/65077069/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-背景"><span class="nav-number">1.</span> <span class="nav-text">1. 背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-请求到DispatcherServlet"><span class="nav-number">2.</span> <span class="nav-text">2. 请求到DispatcherServlet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-DispatcherServlet初始化"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 DispatcherServlet初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Dispatcher处理请求"><span class="nav-number">3.</span> <span class="nav-text">3. Dispatcher处理请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-预处理请求"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 预处理请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-根据请求获取Handler"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 根据请求获取Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-根据处理器获取相应的处理器Adapter适配器"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 根据处理器获取相应的处理器Adapter适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-执行preHandle方法和Handle方法"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 执行preHandle方法和Handle方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-总结"><span class="nav-number">4.</span> <span class="nav-text">4. 总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">轩辕</span>
</div>

<div class="powered-by">
  <!--由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动-->
</div>

<div class="theme-info">
  <!--主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>-->
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zgzczzw"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("HkzSeXgqv4E0fnYfDSnSPqlh-gzGzoHsz", "aJ6qgC0qEVu8NyCBj9zqC7Sr");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

</body>
</html>
